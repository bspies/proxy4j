= Introduction =

Proxy4J is designed for creating proxies in Java with a high degree of flexibility, both in the implementation of the proxying itself as well as in the style of the proxy itself. Currently Proxy4J supports the following proxy styles:
   * *Virtual Proxies*. Also known as delegation proxies, these proxies simply pass the method invocation directly to the "real subject", which may have some indirection in how it is created or fetched (e.g. the classic lazy-loading proxy).
   * *Invocation Handlers*. These are a direct parallel to proxies in the JDK, with a slight twist to include type safety in the common case where only one interface is being proxied. Method calls on these proxies are passed to an invocation handler which decides how to handle the call.
   * *Interceptors*. These are proxies where one or more interceptors may get called prior to invoking the method on the "real subject". In Proxy4J interceptors are very granular and may be specified on a per-method basis. 


= Getting Started =

The centerpiece of the Proxy4J library is the [http://code.google.com/p/proxy4j/source/browse/trunk/proxy4j/core/src/main/java/org/proxy4j/core/ProxyFactory.java ProxyFactory] interface for creating proxies. So the first step in creating a proxy is to create an instance of an implementation for this interface:
{{{
   ProxyFactory proxyFactory = new CglibProxyFactory();
}}}
Of course, you may also use dependency injection to specify the desired implementation.
{{{
   ProxyFactory proxyFactory = Injector.create(ProxyFactory.class);
}}}
Then, to create the desired proxy, simply invoke the desired createProxy() method on the [http://code.google.com/p/proxy4j/source/browse/trunk/proxy4j/core/src/main/java/org/proxy4j/core/ProxyFactory.java ProxyFactory], or use the buildInterceptor() fluent API to create a custom method interceptor.

For example, creating a lazily-loaded proxy is as easy as creating a virtual proxy by passing in the appropriate [http://code.google.com/p/proxy4j/source/browse/trunk/proxy4j/core/src/main/java/org/proxy4j/core/init/LazyProvider.java LazyProvider]:

{{{
  Foo fooProxy = proxyFactory.createProxy(Foo.class, new LazyProvider<Foo>() {
     @Override protected Foo init() {
        return new Foo();
     }
  });
}}}

= Virtual Proxies =

Virtual proxies in Proxy4J use the javax.inject.Provider interface to provide a level of indirection in fetching or creating the "real subject" of the proxy. Use of this interface also has the added benefit of allowing the reuse of existing dependency injection bindings in Spring or Guice. As shown in the example above, the canonical use case for virtual proxies is lazy loading.

= Invocation Handlers =



= ProxyFactory Implementations =

Proxy4J currently supports the following implementations:
  * [http://cglib.sourceforge.net/ CGLIB] is a byte-code manipulation library built on top of [http://asm.ow2.org/ ASM]. It is supported in Proxy4J through the [http://code.google.com/p/proxy4j/source/browse/trunk/proxy4j/core/src/main/java/org/proxy4j/core/cglib/CglibProxyFactory.java CglibProxyFactory] implementation.
  * [http://www.csg.is.titech.ac.jp/~chiba/javassist/ Javassist] is a lightweight Java runtime compiler and bytecode manipulation library. It is supported in Proxy4J through the [http://code.google.com/p/proxy4j/source/browse/trunk/proxy4j/core/src/main/java/org/proxy4j/core/javassist/JavassistProxyFactory.java JavassistProxyFactory] implementation.

= Custom Classloaders =

All implementations of ProxyFactory extend the abstract base class [http://code.google.com/p/proxy4j/source/browse/trunk/proxy4j/core/src/main/java/org/proxy4j/core/BaseProxyFactory.java BaseProxyFactory], which allows you to specify a preferred ClassLoader.